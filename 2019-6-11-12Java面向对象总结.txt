6月10号：
一、数组
   1、数组变量只是管理者 （字符串也是一个管理者）
   2、forEach循环 只能用来遍历数组，不可以改变数组元素本身的值
      注意：要看数组元素是变量还是一个对象：foreach循环不可以改变变量的值，但是可以用它去改变对象的值。

二、"==" 和 .equals  的区别：
      System.out.println(s=="bye");   //输出false 比较的是他俩是否是同一个东西，相当于比较容器
      System.out.println(s.equals("bye"));  //输出true  比较的是.equals字符串中的内容，比较的是其内容是否相同

三、Scanner in = new Scanner(System.in);
    in.next();//会输入一个单次，见到空格会停止输入   空格包括：“空格键，Tab和换行”
	in.nextLine();//会输入一整行

四、字符串的一些常用方法：
    注意：字符串的方法都不改变字符串本身。
    .length()带括号，和数组区分，数组是成员不带括号；
	.charAt()根据下标找该下标处的字符
	.indexOf()根据字符查看下标

五、 运用 辗转相除法  求两个数的 最大公约数
     int gcd(int x, int y){ // 这个是运用 辗转相除法  求两个数的 最大公约数
        if(y == 0)
            return x;
        else
            return gcd(y,x%y);
        }


6月11号：
  面向对象
   1、对象 = 属性 + 服务
   2、封装：就是把数据和对数据的操作放在一起.
   3、private : 本类
      defaud ：只在本包
      protect ：只在本包，或子类
	  public ：所有地方


   4、需要用别的包里面的类的时候，需要用import 引入类
   5、static 修饰变量：类变量，可以用类名直接调用。被static修饰的变量不在对象当中，但是因为对象属于类，因此可以通过对象调用类变量。
                       类变量只初始化一次，和新创建对象无关。
   6、Hash表：散列表
   7、this和super的用法：
   8、初始化：定义初始化先做，然后做构造器的初始化
        子类调用了父类的初始化方法时，先做父类的初始化，再做子类的初始化。

	在构造一个子类的对象时，父类的构造方法也是会被调用的，而且父类的构造方法在子类的构造方法之前被调用。在程序运行过程中，
    子类对象的一部分空间存放的是父类对象。因为子类从父类得到继承，在子类对象初始化过程中可能会使用到父类的成员。所以父
	类的空间正是要先被初始化的，然后子类的空间才得到初始化。在这个过程中，如果父类的构造方法需要参数，如何传递参数就很重要了。

    public的成员直接成为子类的public的成员，protected的成员也直接成为子类的protected的成员。Java的protected
	的意思是包内和子类可访问，所以它比缺省的访问属性要宽一些。而对于父类的缺省的未定义访问属性的成员来说，
	他们是在父类所在的包内可见，如果子类不属于父类的包，那么在子类里面，这些缺省属性的成员和private的成员是一样的：
	不可见。父类的private的成员在子类里仍然是存在的，只是子类中不能直接访问。我们不可以在子类中重新定义继承得到的成
	员的访问属性。如果我们试图重新定义一个在父类中已经存在的成员变量，那么我们是在定义一个与父类的成员变量完全无关的变量，
	在子类中我们可以访问这个定义在子类中的变量，在父类的方法中访问父类的那个。尽管它们同名但是互不影响。

   9、多态：一个变量可以保存其所声明的类型或该类型的任何子类型。
	   对象变量可以保存其声明的类型的对象,或该类型的任何子类型的对象。
     Java中保存对象类型的变量是多态变量。“多态”这个术语(字面意思是许多形态)是指一个变量可以保存不同类型(即其声明的类型或任何子类型)的对象。
  10、可扩展性：意思就是代码的某些部分不需要经过修改就能适应将来可能的变化。   使用函数和父类。
  11、实现解耦的方法：利用private事项类的属性和操作的封装。
  12、我们用abstract关键字来定义抽象类。抽象类的作用仅仅是表达接口，而不是具体的实现细节。抽象类中可以存在抽象方法。
      抽象方法也是使用abstract关键字来修饰。抽象的方法是不完全的，它只是一个方法签名而完全没有方法体。
      如果一个类有了一个抽象的方法，这个类就必须声明为抽象类。如果父类是抽象类，那么子类必须覆盖所有在父类中的抽象方法，
	  否则子类也成为一个抽象类。一个抽象类可以没有任何抽象方法，所有的方法都有方法体，但是整个类是抽象的。
      设计这样的抽象类主要是为了防止制造它的对象出来。
  13、Java把抽象的概念又更推进了一步。这就是接口（Interface）。接口其实就是完全抽象的类，因此接口和类的地位是一样的，
      此前所有针对类的所有法则同样适用于接口。接口所有的方法都是没有方法体的，而且都是public abstract，即使你没有这样声明。
	  而接口中的所有成员变量都是public static final的变量，并且必须有定义初始化，因为所有变量都必须在编译的时候有确定值。
      接口和类的地位是一样的。因此我们可以看到其定义方式跟类也是基本上一样的。当然，其中的所有方法都没有方法体。
	  而当类从接口得到继承的时候，Java用另外一个动词：实现（implements）。当然，实现接口的类必须覆盖接口中所有的方法，
	  否则这个类就成为一个抽象类。
     Java不允许多继承，但是允许一个类实现多个接口，也允许一个接口从多个接口得到继承，但是不允许接口从类继承。

6月12号：
   1、内部类就是指一个类定义在另一个类的内部，从而成为外部类的一个成员。因此一个类中可以有成员变量、方法，
      还可以有内部类。实际上Java的内部类可以被称为成员类，内部类实际上是它所在类的成员。所以内部类也就具有和成员变量、
      成员方法相同的性质。比如，成员方法可以访问私有变量，那么成员类也可以访问私有变量了。
      也就是说，成员类中的成员方法都可以访问成员类所在类的私有变量。内部类最重要的特点就是能够访问外部类的所有成员。

	注意：有两种内部类，一种是在类里面，但是不在函数里面的，另一种是在函数里面的内部类
	      细节：在函数里面的内部类，访问该函数的局部变量的时候，只能访问final修饰的局部变量。

		成员内部类
            类比成员方法成员
		1.内部类内部不允许存在任何static变量或方法 正如成员方法中不能有任何静态属性 （成员方法与对象相关、静态属性与类有关）
        2.成员内部类是依附外部类的，只有创建了外部类才能创建内部类。

		静态内部类
            关键字static可以修饰成员变量、方法、代码块、其实还可以修饰内部类，使用static修饰的内部类我们称之为静态内部类，
		静态内部类和非静态内部类之间存在一个最大的区别，非静态内部类在编译完成之后会隐含的保存着一个引用，该引用是指
		向创建它的外围类，但是静态类没有。没有这个引用就意味着：
        1.静态内部类的创建不需要依赖外部类可以直接创建。
        2.静态内部类不可以使用任何外部类的非static类（包括属性和方法），但可以存在自己的成员变量。

		匿名内部类:
             就是一个没有名字的方法内部类，因此特点和方法与方法内部类完全一致，除此之外，还有自己的特点：
        1.匿名内部类必须继承一个抽象类或者实现一个接口。
        2.匿名内部类没有类名，因此没有构造方法。

	  通过内部类可以实现控制反转（注入反转）。

   2、MVC：MVC全名是Model View Controller，是模型(model)－视图(view)－控制器(controller)的缩写，一种软件设计典范，
           用一种业务逻辑、数据、界面显示分离的方法组织代码，将业务逻辑聚集到一个部件里面，在改进和个性化定制界面及用户交互的同时，
           不需要重新编写业务逻辑。MVC被独特的发展起来用于映射传统的输入、处理和输出功能在一个逻辑的图形化用户界面的结构中。

   3、控制反转（注入反转），注入依赖：从注入方法上看，主要可以划分为三种类型：构造函数注入、属性注入和接口注入。
                                      Spring支持构造函数注入和属性注入。下面我们继续使用以上的例子说明这三种注入方法的区别。
   4、Static:
          static修饰的方法：static方法一般称作静态方法，由于静态方法不依赖于任何对象就可以进行访问，因此对于静态方法来说，
	  是没有this的，因为它不依附于任何对象，既然都没有对象，就谈不上this了。并且由于这个特性，

	      在静态方法中不能访问类的非静态成员变量和非静态成员方法，因为  非静态成员方法/变量都是必须依赖具体的对象 才能够被调用。

          而对于非静态成员方法，它访问静态成员方法/变量显然是毫无限制的。
	      想在不创建对象的情况下调用某个方法，就可以将这个方法设置为static。我们最常见的static方法就是main方法，至于为什么
	  main方法必须是static的，现在就很清楚了。因为程序在执行main方法的时候没有创建任何对象，因此只有通过类名来访问。
	      static修饰的变量：也称作静态变量，静态变量和非静态变量的区别是：静态变量被所有的对象所共享，在内存中只有一个副本，
	  它当且仅当在类初次加载时会被初始化。而非静态变量是对象所拥有的，在创建对象的时候被初始化，存在多个副本，各个对象
	  拥有的副本互不影响。
          static成员变量的初始化顺序按照定义的顺序进行初始化。
          static代码块：static关键字还有一个比较关键的作用就是用来形成静态代码块以优化程序性能。static块可以置于类中的任何地方，
		  类中可以有多个static块。在类初次被加载的时候，会按照static块的顺序来执行每个static块，并且只会执行一次。

	 在Java中切记：static是不允许用来修饰局部变量。

	      java里面static一般用来修饰成员变量或函数。但有一种特殊用法是用static修饰  内部类 ，普通类是不允许声明为静态的，
	  只有内部类才可以。
	被static修饰的内部类可以直接作为一个普通类来使用，而不需实例一个外部类。
      需要注意的是当一个内部类 没有使用static修饰的时候，是不能直接使用内部类创建对象，须要先使用外部类对象点new内部类对象及

		  没有static 修饰内部类:  (外部类对象.new 内部类（）)    OuterClass oc = new OuterClass();  oc.new InnerClass();
		  有static 修饰内部类时:  new OuterClass.InnerClass();

6月13号：
 1、对于类的设计来说，有两个核心术语：耦合和聚合。 耦合这个词指的是类和类之间的联系。之前的章节中提到过，程序设计的目标是一
    系列通 过定义明确的接口通信来协同工作的类。耦合度反映了这些类联系的紧密度。我们努力要获得 低的耦合度，或者叫作松耦合
	（loose coupling）。
	    耦合的定义：耦合（Couping）是模块之间相关联程度的度量。
	    相对于聚合的内向性，耦合关注的是某一模块和其他模块之间的关联性。也就是说模块之间的关联尽量越少越好。
		耦合主要指不同对象之间相互关联的程度。如果一个对象过多地依赖于其它对象来完成自己的工作，则不仅使该对象的可理解性下降，
	而且还会增加测试、修改的难度，同时降低了类的可重用性和可移植性。对象不可能是完全孤立的，当两个对象必须相互联系时，应该通
	过类的公共接口实现耦合，不应该依赖于类的具体实现细节。

	    交互耦合——如果对象之间的耦合是通过消息连接来实现的，则这种耦合就是交互耦合。在设计时应该尽量减少对象之间发送的消息数
	和消息中的参数个数，降低消息连接的复杂程度。
        继承耦合——继承耦合是一般化类与特殊化类之间的一种关联形式，设计时应该适当使用这种耦合。在设计时要特别认真分析一般化类
	与特殊化类之间继承关系，如果抽象层次不合理，可能会造成对特殊化类的修改影响到一般化类,使得系统的稳定性降低。另外，
	在设计时特殊化类应该尽可能多地继承和使用一般化类的属性和服务，充分利用继承的优势。

        耦合度决定修改应用程序的容易程度。在一个紧耦合的结构中，对一个类的修改也会导致对其他一些类的修改。这是要努力避免的，否则，
    一点小小的改变就可能使整个应用程序发生 改变。另外，要想找到所有需要修改的地方，并一一加以修改，却是一件既困难又费时的事情。
	另一方面，在一个松耦合的系统中，常常可以修改一个类，但同时不会修改其他类，而且整个程序还可以正常运作。
        聚合的定义：聚合（Cohesion）是一个模块内部各成分之间相关联程度的度量。
		  通俗来讲：高内聚指的是：一个模块仅完成一个独立的功能，模块内部不存在与该功能无关的操作或状态。
		聚合与程序中一个单独的单元所承担的任务的数量和种类相对应有关，它是针对类或方法，这样大小的程序单元而言的理想情况下，
	一个代码单元应该负责一个聚合的任务（也就是说，一个任务可以被看作是 一个逻辑单元）。
	一个方法应该实现一个逻辑操作，而一个类应该代表一定类型的实体。
	聚合 理论背后的要点是  重用：如果一个方法或类是只负责一件定义明确的事情，那么就很有可能在另外不同的上下文环境中使用。
    遵循这个理论的一个额外的好处是，当程序某部分的代码需要 改变时，在某个代码单元中很可能会找到所有需要改变的相关代码段。

	程序代码的要求是：“高内聚，低耦合”。

2、低耦合高内聚的实现:
	起因：模块独立性指每个模块只完成系统要求的独立子功能，并且与其他模块的联系最少且接口简单，两个定性的度量标准――耦合性和内聚性。

    耦合性也称块间联系。指软件系统结构中各模块间相互联系紧密程度的一种度量。模块之间联系越紧密，其耦合性就越强，模块的独立性则
越差。模块间耦合高低取决于模块间接口的复杂性、调用的方式及传递的信息。
    耦合性分类(低――高): 无直接耦合;数据耦合;标记耦合;控制耦合;公共耦合;内容耦合;
1 无直接耦合:
2 数据耦合: 指两个模块之间有调用关系，传递的是简单的数据值，相当于高级语言的值传递;
3 标记耦合: 指两个模块之间传递的是数据结构，如高级语言中的数组名、记录名、文件名等这些名字即标记，其实传递的是这个数据结构的地址;
4 控制耦合: 指一个模块调用另一个模块时，传递的是控制变量（如开关、标志等），被调模块通过该控制变量的值有选择地执行块内某一功能;
5 公共耦合: 指通过一个公共数据环境相互作用的那些模块间的耦合。公共耦合的复杂程序随耦合模块的个数增加而增加。
6 内容耦合: 这是最高程度的耦合，也是最差的耦合。当一个模块直接使用另一个模块的内部数据，或通过非正常入口而转入另一个模块内部。

    内聚性又称块内联系。指模块的功能强度的度量，即一个模块内部各个元素彼此结合的紧密程度的度量。若一个模块内各元素（语名之间、
程序段之间）联系的越紧密，则它的内聚性就越高。
    内聚性分类(低――高): 偶然内聚;逻辑内聚;时间内聚;通信内聚;顺序内聚;功能内聚;
1 偶然内聚: 指一个模块内的各处理元素之间没有任何联系。
2 逻辑内聚: 指模块内执行几个逻辑上相似的功能，通过参数确定该模块完成哪一个功能。
3 时间内聚: 把需要同时执行的动作组合在一起形成的模块为时间内聚模块。
4 通信内聚: 指模块内所有处理元素都在同一个数据结构上操作（有时称之为信息内聚），或者指各处理使用相同的输入数据或者产生相同的
            输出数据。
5 顺序内聚: 指一个模块中各个处理元素都密切相关于同一功能且必须顺序执行，前一功能元素输出就是下一功能元素的输入。
6 功能内聚: 这是最强的内聚，指模块内所有元素共同完成一个功能，缺一不可。与其他模块的耦合是最弱的。

   耦合性与内聚性是模块独立性的两个定性标准，将软件系统划分模块时，尽量做到高内聚低耦合，提高模块的独立性，为设计高质量的软件
 结构奠定基础。

    有个例子很容易明白：一个程序有50个函数，这个程序执行得非常好；然而一旦你修改其中一个函数，其他49个函数都需要做修改，这就是
高耦合的后果。

